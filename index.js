'use strict';

function _asyncToGenerator(fn) { return function () { var gen = fn.apply(this, arguments); return new Promise(function (resolve, reject) { function step(key, arg) { try { var info = gen[key](arg); var value = info.value; } catch (error) { reject(error); return; } if (info.done) { resolve(value); } else { return Promise.resolve(value).then(function (value) { step("next", value); }, function (err) { step("throw", err); }); } } return step("next"); }); }; }

// Generated by CoffeeScript 2.1.1
(function () {
  // This file is part of browserify-helpers
  // Copyright (C) 2018-present Dario Giovannetti <dev@dariogiovannetti.net>
  // Licensed under MIT
  // https://github.com/kynikos/browserify-helpers/blob/master/LICENSE
  var Readable, babelify, browserify, coffeeify, error, fs, lessify_, sassify_, uglify, uglifyjs;

  require('babel-polyfill');

  fs = require('fs');

  var _require = require('stream');

  Readable = _require.Readable;


  browserify = require('browserify');

  coffeeify = require('coffeeify');

  babelify = require("babelify");

  uglifyjs = require("uglify-js");

  try {
    sassify_ = require('sassify');
  } catch (error1) {
    error = error1;
    sassify_ = null;
  }

  try {
    lessify_ = require('lessify');
  } catch (error1) {
    error = error1;
    lessify_ = null;
  }

  uglify = function uglify(instream) {
    var jscode, outstream, uglifying;
    jscode = "";
    outstream = new Readable();
    instream.on('readable', function () {
      var buffer;
      buffer = instream.read();
      if (buffer) {
        return jscode += buffer.toString();
      }
    });
    uglifying = new Promise(function (resolve, reject) {
      instream.on('end', function () {
        var minjs;
        minjs = uglifyjs.minify(jscode);
        outstream.push(minjs.code);
        // https://stackoverflow.com/a/22085851
        outstream.push(null);
        return resolve(outstream);
      });
      return instream.on('error', function (error) {
        return reject(error);
      });
    });
    return uglifying;
  };

  module.exports.jspack = function () {
    var _ref2 = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee(entry, bundlepath, _ref) {
      var _ref$require = _ref.require,
          require = _ref$require === undefined ? null : _ref$require,
          _ref$external = _ref.external,
          external = _ref$external === undefined ? [] : _ref$external,
          _ref$sassify = _ref.sassify,
          sassify = _ref$sassify === undefined ? false : _ref$sassify,
          _ref$lessify = _ref.lessify,
          lessify = _ref$lessify === undefined ? false : _ref$lessify,
          _ref$debug = _ref.debug,
          debug = _ref$debug === undefined ? false : _ref$debug;

      var bfy, extfile, i, jsstream, len, outstream;
      return regeneratorRuntime.wrap(function _callee$(_context) {
        while (1) {
          switch (_context.prev = _context.next) {
            case 0:
              bfy = browserify(entry, {
                extensions: ['.coffee'],
                debug: debug
              });
              if (require) {
                bfy.require(require);
              }
              for (i = 0, len = external.length; i < len; i++) {
                extfile = external[i];
                bfy.external(extfile);
              }
              bfy.transform(coffeeify);

              if (!sassify) {
                _context.next = 8;
                break;
              }

              if (sassify_) {
                _context.next = 7;
                break;
              }

              throw new Error("'sassify' is not installed");

            case 7:
              bfy.transform(sassify_, {
                global: true
              });

            case 8:
              if (!lessify) {
                _context.next = 12;
                break;
              }

              if (lessify_) {
                _context.next = 11;
                break;
              }

              throw new Error("'lessify' is not installed");

            case 11:
              bfy.transform(lessify_, {
                global: true
              });

            case 12:
              bfy.transform(babelify, {
                presets: ["env"],
                // Yes, it is needed to repeat the 'extensions' option here
                extensions: [".coffee"],
                comments: false,
                compact: false
              });
              jsstream = bfy.bundle();

              if (debug) {
                _context.next = 18;
                break;
              }

              _context.next = 17;
              return uglify(jsstream);

            case 17:
              jsstream = _context.sent;

            case 18:
              outstream = jsstream.pipe(fs.createWriteStream(bundlepath));
              return _context.abrupt('return', new Promise(function (resolve, reject) {
                outstream.on('close', function () {
                  return resolve(outstream);
                });
                return outstream.on('error', function (error) {
                  return reject(error);
                });
              }));

            case 20:
            case 'end':
              return _context.stop();
          }
        }
      }, _callee, this);
    }));

    return function (_x, _x2, _x3) {
      return _ref2.apply(this, arguments);
    };
  }();
}).call(undefined);